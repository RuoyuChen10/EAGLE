# -- coding: utf-8 --**

"""
Created on 2024/10/25

@author: Ruoyu Chen
"""

import argparse

import os
import os
import json
import cv2
import numpy as np
from matplotlib import pyplot as plt
from PIL import Image

from tqdm import tqdm

from sklearn import metrics
from utils import *
from visualization.visualization import add_value

import math

def parse_args():
    parser = argparse.ArgumentParser(description='Point Game')
    parser.add_argument('--Datasets',
                        type=str,
                        default='datasets/coco/val2017',
                        help='Datasets.')
    parser.add_argument('--explanation-dir', 
                        type=str, 
                        default='interpretation_results/LLaVA-1_5-7B-coco-object/slico-1.0-1.0-division-number-64',
                        help='Save path for saliency maps generated by our methods.')
    args = parser.parse_args()
    return args

def segmentation_to_mask(segmentation, w, h):
    """
    Convert COCO-style segmentation(s) to a binary mask of shape (h, w).
    Supports:
      - single polygon: [x1, y1, x2, y2, ...]
      - multiple polygons: [[x1, y1, ...], [x1, y1, ...], ...]
    Returns uint8 mask with values {0,1}.
    """
    mask = np.zeros((h, w), dtype=np.uint8)

    if segmentation is None:
        return mask

    # If it's a dict, it may be RLE. (Optional) handle via pycocotools if you use RLEs.
    if isinstance(segmentation, dict) and "counts" in segmentation:
        try:
            import pycocotools.mask as maskUtils
            # Ensure RLE is in the proper compressed form
            rle = segmentation
            if not isinstance(rle["counts"], bytes):
                rle = maskUtils.frPyObjects([segmentation], h, w)[0]
            m = maskUtils.decode(rle)
            # m is {0,1} uint8/uint32; ensure to uint8
            return (m.astype(np.uint8)).clip(0,1)
        except Exception as e:
            raise ValueError(f"RLE segmentation provided but pycocotools decode failed: {e}")

    # Normalize to list of polygons
    if isinstance(segmentation, (list, tuple, np.ndarray)) and len(segmentation) > 0:
        # multiple polygons: list of lists
        if isinstance(segmentation[0], (list, tuple, np.ndarray)):
            polygons = segmentation
        else:
            # single polygon: flat list
            polygons = [segmentation]
    else:
        return mask  # empty

    for poly in polygons:
        if poly is None or len(poly) < 6:
            # need at least 3 points -> 6 numbers
            continue
        pts = np.asarray(poly, dtype=np.float32).reshape(-1, 2)
        # round and cast to int
        pts = np.round(pts).astype(np.int32)
        # clip to image bounds
        pts[:, 0] = np.clip(pts[:, 0], 0, w - 1)
        pts[:, 1] = np.clip(pts[:, 1], 0, h - 1)
        # fill
        cv2.fillPoly(mask, [pts], 1)

    return mask

def point_game_mask(segmentation, saliency_map):
    h, w = saliency_map.shape
    empty = segmentation_to_mask(segmentation, w, h)

    mask_bbox = saliency_map * empty

    if mask_bbox.max() == saliency_map.max():
        return 1
    else:
        return 0

def point_game(bbox, saliency_map):
  
    x1, y1, x2, y2 = bbox
    w, h = saliency_map.shape   # Not bug

    empty = np.zeros((w, h))
    empty[y1:y2, x1:x2] = 1
    mask_bbox = saliency_map * empty
    
    if mask_bbox.max() == saliency_map.max():
        return 1
    else:
        return 0
    
def main(args):
    json_root_file = os.path.join(args.explanation_dir, "json")
    npy_root_file = os.path.join(args.explanation_dir, "npy")
    json_file_names = os.listdir(json_root_file)
    
    pg_box_value = []
    pg_seg_value = []
    
    for json_file_name in tqdm(json_file_names):
        json_file_path = os.path.join(json_root_file, json_file_name)
        npy_file_path = os.path.join(npy_root_file, json_file_name.replace(".json", ".npy"))
        
        image_path = os.path.join(args.Datasets, json_file_name.replace(".json", ".jpg"))
        
        with open(json_file_path, 'r', encoding='utf-8') as f:
            saved_json_file = json.load(f)
        
        image = cv2.imread(image_path)
        
        if "interpretation_results" in npy_file_path:
            S_set = np.load(npy_file_path)
            attribution_map, _ = add_value(S_set, saved_json_file)
            
            attribution_map = cv2.resize(attribution_map.astype(float), (image.shape[1], image.shape[0]))
            
        else:
            attribution_map = np.load(npy_file_path)
            if math.isnan(attribution_map.min()):
                # print("bad")
                pg_seg_value.append(0)
                pg_box_value.append(0)
                continue
            attribution_map = attribution_map - attribution_map.min()
            attribution_map = attribution_map / (attribution_map.max() + 0.00000001)
            attribution_map = cv2.resize(attribution_map, (image.shape[1], image.shape[0]), interpolation=cv2.INTER_LINEAR)
        
        pg_box = point_game(saved_json_file["location"], attribution_map)
        pg_seg = point_game_mask(saved_json_file["segmentation"], attribution_map)

        pg_box_value.append(pg_box)
        pg_seg_value.append(pg_seg)
    
    print("Point Game (Box): {}".format(np.array(pg_box_value).mean()))
    print("Point Game (Mask): {}".format(np.array(pg_seg_value).mean()))
    
if __name__ == "__main__":
    args = parse_args()
    main(args)